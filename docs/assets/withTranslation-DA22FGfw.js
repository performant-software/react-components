import{r as i}from"./iframe-CBVnS_gz.js";import{I as F,g as M,R as O,w as P,h as p,a as z,l as C,d as j,i as R,c as _,e as $}from"./context-e-3OPt86.js";const k=(r,t)=>{const o=i.useRef();return i.useEffect(()=>{o.current=r},[r,t]),o.current},A=(r,t,o,c)=>r.getFixedT(t,o,c),v=(r,t,o,c)=>i.useCallback(A(r,t,o,c),[r,t,o,c]),L=(r,t={})=>{const{i18n:o}=t,{i18n:c,defaultNS:g}=i.useContext(F)||{},e=o||c||M();if(e&&!e.reportNamespaces&&(e.reportNamespaces=new O),!e){P(e,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const a=(l,d)=>R(d)?d:_(d)&&R(d.defaultValue)?d.defaultValue:Array.isArray(l)?l[l.length-1]:l,u=[a,{},!1];return u.t=a,u.i18n={},u.ready=!1,u}e.options.react?.wait&&P(e,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const s={...z(),...e.options.react,...t},{useSuspense:m,keyPrefix:w}=s;let n=g||e.options?.defaultNS;n=R(n)?[n]:n||["translation"],e.reportNamespaces.addUsedNamespaces?.(n);const f=(e.isInitialized||e.initializedStoreOnce)&&n.every(a=>p(a,e,s)),y=v(e,t.lng||null,s.nsMode==="fallback"?n:n[0],w),I=()=>y,E=()=>A(e,t.lng||null,s.nsMode==="fallback"?n:n[0],w),[S,T]=i.useState(I);let h=n.join();t.lng&&(h=`${t.lng}${h}`);const b=k(h),N=i.useRef(!0);i.useEffect(()=>{const{bindI18n:a,bindI18nStore:u}=s;N.current=!0,!f&&!m&&(t.lng?C(e,t.lng,n,()=>{N.current&&T(E)}):j(e,n,()=>{N.current&&T(E)})),f&&b&&b!==h&&N.current&&T(E);const l=()=>{N.current&&T(E)};return a&&e?.on(a,l),u&&e?.store.on(u,l),()=>{N.current=!1,e&&a?.split(" ").forEach(d=>e.off(d,l)),u&&e&&u.split(" ").forEach(d=>e.store.off(d,l))}},[e,h]),i.useEffect(()=>{N.current&&f&&T(I)},[e,w,f]);const x=[S,e,f];if(x.t=S,x.i18n=e,x.ready=f,f||!f&&!m)return x;throw new Promise(a=>{t.lng?C(e,t.lng,n,()=>a()):j(e,n,()=>a())})},J=(r,t={})=>function(c){function g({forwardedRef:s,...m}){const[w,n,f]=L(r,{...m,keyPrefix:t.keyPrefix}),y={...m,t:w,i18n:n,tReady:f};return t.withRef&&s?y.ref=s:!t.withRef&&s&&(y.forwardedRef=s),i.createElement(c,y)}g.displayName=`withI18nextTranslation(${$(c)})`,g.WrappedComponent=c;const e=(s,m)=>i.createElement(g,Object.assign({},s,{forwardedRef:m}));return t.withRef?i.forwardRef(e):g};export{J as w};
