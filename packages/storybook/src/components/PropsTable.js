// @flow

import React, { useMemo } from 'react';
import _ from 'underscore';
import DataTable from '../../../semantic-ui/src/components/DataTable';
import i18n from '../i18n/i18n';
import Label from './Label';
import useDragDrop from '../../../shared/src/utils/DragDrop';
import withDocumentation from '../hooks/Documentation';
import './PropsTable.css';

type Props = {
  props: {
    [key: string]: {
      defaultValue?: {
        computed: boolean,
        value: any
      },
      flowType: {
        type: string
      },
      required: boolean
    }
  }
};

/**
 * This component renders a props table for the passed "props". The "props" will be generated by react-docgen
 * and converted into developer-readable syntax.
 *
 * @param props
 *
 * @returns {JSX.Element}
 *
 * @constructor
 */
const PropsTable = (props: Props) => {
  /**
   * Maps the passed "props" into a collection of items.
   */
  const items = useMemo(() => {
    const keys = Object.keys(props.props || {}).sort();
    return _.map(keys, (key) => ({ key, ...props.props[key] }));
  }, [props.props]);

  /**
   * Renders a code block with the passed label. The value will be wrapped in a <code> tag.
   *
   * @param label
   * @param value
   *
   * @returns {JSX.Element}
   */
  const renderCode = (label, value) => (
    <div
      style={{
        marginTop: '1em'
      }}
    >
      <b>{ label }</b>
      <div
        className='code-container'
        dangerouslySetInnerHTML={{
          __html: `<code>${value}</code>`
        }}
      />
    </div>
  );

  /**
   * Renders the function based on the passed Flow type.
   *
   * @param flowType
   *
   * @returns {JSX.Element|null}
   */
  const renderFunction = (flowType = {}) => {
    if (flowType.type !== 'function') {
      return null;
    }

    const { args, returnValue } = resolveFunction(flowType);
    return renderCode(i18n.t('PropsTable.labels.signature'), `(${args}) => ${returnValue}`);
  };

  /**
   * Returns the type column based on the passed Flow type.
   *
   * @param flowType
   *
   * @returns {JSX.Element|null}
   */
  const renderType = (flowType = {}) => {
    if (!(flowType.elements || flowType.type === 'object')) {
      return null;
    }

    let value = resolveValue(flowType);
    if (flowType.type === 'object') {
      value = JSON.stringify(value, null, 2);
    }

    return renderCode(i18n.t('PropsTable.labels.type'), value);
  };

  /**
   * Renders the description for the passed set of attributes.
   *
   * @param attributes
   *
   * @returns {JSX.Element}
   */
  const renderDescription = (attributes) => {
    const { description, flowType } = attributes;

    return (
      <div>
        <span
          dangerouslySetInnerHTML={{
            __html: description
          }}
        />
        { renderFunction(flowType) }
        { renderType(flowType) }
      </div>
    );
  };

  /**
   * Returns the code string for the passed arg.
   *
   * @param arg
   *
   * @returns {string}
   */
  const resolveArgument = (arg) => {
    let value = `${arg.name}: ${arg.type.name}`;

    if (arg.type.elements) {
      value += resolveElements(arg.type.elements);
    }

    return value;
  };

  /**
   * Returns the code string for the passed collection of elements. If the "type" of the element is an object,
   * we'll use JSON to format the resulting object.
   *
   * @param elements
   *
   * @returns {`&lt;${*}&gt;`}
   */
  const resolveElements = (elements) => (
    `&lt;${_.map(elements, (element) => (element.type === 'object'
      ? JSON.stringify(resolveValue(element), undefined, 2)
      : resolveValue(element))).join(',')}&gt;`
  );

  /**
   * Renders the type value based on the passed Flow type.
   *
   * @type {unknown}
   */
  const resolveValue = (flowType = {}) => {
    let value;

    if (flowType.type === 'function') {
      const { args, returnValue } = resolveFunction(flowType);
      value = `(${args}) => ${returnValue}`;
    } else if (flowType.type === 'object') {
      value = resolveObject(flowType.signature.properties);
    } else if (flowType.name === 'union' || flowType.name === 'intersection') {
      value = flowType.raw;
    } else {
      value = flowType.type || flowType.name;
    }

    if (flowType.elements) {
      value += resolveElements(flowType.elements);
    }

    return value;
  };

  /**
   * Converts the passed collection of properties to an object.
   *
   * @param properties
   *
   * @returns {*}
   */
  const resolveObject = (properties) => {
    const attributes = _.map(properties, (prop) => ({
      [prop.key]: resolveValue(prop.value)
    }));

    return Object.assign({}, ...attributes);
  };

  /**
   * Returns the code string for the passed function.
   *
   * @param flowType
   *
   * @returns {{args: *, returnValue: *}}
   */
  const resolveFunction = (flowType) => {
    const args = _.map(flowType.signature.arguments, resolveArgument).join(', ');
    let returnValue = resolveValue(flowType.signature.return);

    if (flowType.signature.return.type === 'object') {
      returnValue = JSON.stringify(returnValue, undefined, 2);
    }

    return { args, returnValue };
  };

  return (
    <DataTable
      addButton={{}}
      columns={[{
        name: 'name',
        label: i18n.t('PropsTable.columns.name'),
        render: (item) => (
          <Label
            content={item.key}
            required={item.required}
          />
        )
      }, {
        name: 'type',
        className: 'type',
        label: i18n.t('PropsTable.columns.type'),
        render: (item) => item.flowType?.type || item.flowType?.name
      }, {
        name: 'default',
        label: i18n.t('PropsTable.columns.default'),
        resolve: (item) => item.defaultValue?.value
      }, {
        name: 'description',
        className: 'description',
        label: i18n.t('PropsTable.columns.description'),
        render: (item) => renderDescription(item)
      }]}
      items={items}
      tableProps={{
        basic: 'very',
        className: 'props-table'
      }}
    />
  );
};

export default useDragDrop(withDocumentation(PropsTable));
